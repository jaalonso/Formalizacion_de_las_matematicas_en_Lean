#+TITLE: 5Âª clase de "FormalizaciÃ³n de las matemÃ¡ticas": Filtros

La palabra "filtro" significa diferentes cosas para diferentes personas; solo
para aclarar, esta semana aprenderemos sobre la nociÃ³n matemÃ¡tica de un [[https://en.wikipedia.org/wiki/Filter_(mathematics)#Filter_on_a_set][filtro
en un conjunto]]. He [[https://xenaproject.wordpress.com/2018/08/04/what-is-a-filter-how-some-computer-scientists-think-about-limits/][escrito sobre estos filtros antes]], pero desde entonces me las
arreglÃ© para comprender mucho mejor cÃ³mo pensar en los filtros, y espero que
esto se vea aquÃ­. Cuando escribÃ­ esa publicaciÃ³n en 2018, sabÃ­a que los filtros
eran "algo que tiene que ver con los lÃ­mites", pero ahora me doy cuenta de que
esto estÃ¡ mal. Se utilizan para hablar de lÃ­mites, pero lo que es un filtro en
sÃ­ mismo es simplemente una generalizaciÃ³n de un subconjunto de un conjunto.

* Â¿QuÃ© es un filtro?

Sea \(X\) un tipo; es decir, lo que la mayorÃ­a de los matemÃ¡ticos llaman
conjunto. Luego \(X\) tiene subconjuntos, y la colecciÃ³n de todos los subconjuntos
de $X$ tiene algunas propiedades realmente agradables: puede tomar uniones e
intersecciones arbitrarias, por ejemplo, y si se ordena los subconjuntos de
\(X\) por inclusiÃ³n, entonces estas construcciones se pueden considerar como
supremos e Ã­nfimos y satisfacen un conjunto de axiomas que uno podrÃ­a esperar
que satisfagan los supremos e Ã­nfimos; por ejemplo, si \(X_i âŠ‚ Y\) para todo \(i
âˆˆ I\), entonces \(â‹ƒ_i X_i âŠ† Y\). En resumen, los subconjuntos de un conjunto
forman lo que se conoce en la teorÃ­a del orden como un retÃ­culo completo.

Se puede pensar en un filtro como una especie de subconjunto generalizado de
\(X\). Cada subconjunto \(S\) de \(X\) da lugar a un filtro de \(X\), llamado
filtro principal asociado a \(S\) y denotado por \(ğ“Ÿ S\). Tenemos \(ğ“Ÿ S = ğ“Ÿ T\)
si y solo si \(S = T\). Sin embargo, si \(X\) es infinito, hay otros filtros
\(F\) no principales de \(X\), que son objetos un poco mÃ¡s vagos. Sin embargo,
los filtros tienen un orden escrito \(F â‰¤ G\), y es cierto que
\(S âŠ† T â†” ğ“Ÿ S â‰¤ ğ“Ÿ T\) (de hecho, lo demostraremos hoy). Para dar un ejemplo de
un filtro que no es principal, sea \(X\) los nÃºmeros reales. Para cada nÃºmero
real \(x\) hay un filtro \(ğ“ x\), llamado filtro de entornos de x, con la
propiedad de que si \(U\) es cualquier subconjunto abierto de \(â„\)
que contiene a \(x\), entonces \(ğ“Ÿ {x} < ğ“ x < ğ“Ÿ U\). En otras palabras, es
una especie de "entorno infinitesimal de \(x)", estrictamente mÃ¡s grande que
\({x}\) pero estrictamente mÃ¡s pequeÃ±o que cada entorno abierto de \(x\). Este
es un concepto que no se puede formalizar solo con conjuntos, sino que se puede
formalizar mediante filtros.

* La definiciÃ³n formal de un filtro

DÃ©jame motivar la definiciÃ³n antes de darla. Sea \(F\) un filtro. Definamos
=F.sets= como los subconjuntos de \(X\) que contienen F; es decir, los \(S\)
tales que \(F â‰¤ ğ“Ÿ S\). AquÃ­ hay una propiedad de los filtros que aÃºn no he
mencionado: si dos filtros \(F\) y \(G\) satisfacen ~F.sets = G.sets~ entonces
\(F = G\); en otras palabras, un filtro estÃ¡ determinado por los filtros
principales que lo contienen. Esto motiva la siguiente definiciÃ³n: Â¿por quÃ© no
definir un filtro \(F\) como el conjunto de subconjuntos de \(X\) que lo
contienen?  Necesitaremos algunos axiomas: Â¿cuÃ¡les son los axiomas razonables?
No queremos que un filtro sea mÃ¡s grande que \(X\) y queremos asegurarnos de que
si \(S\) contiene a \(F\), entonces \(T\) contiene a \(F\) para cualquier \(T âŠ‡
S\); finalmente, si ambos \(S\) y \(T\) contienen $F$ entonces queremos que $S âˆ©
T$ contenenga a $F$. Â¡Esa es la definiciÃ³n de filtro!

#+begin_src lean
structure filter (Î± : Type*) :=
(sets                   : set (set Î±))
(univ_sets              : set.univ âˆˆ sets)
(sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets)
(inter_sets {x y}       : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets)
#+end_src

Un filtro en $X$, o, como Lean le gustarÃ­a llamarlo, un tÃ©rmino ~F : filter X~
de tipo ~filter X~, es una colecciÃ³n ~F.sets~ de subconjuntos de $X$ que
satisfacen los tres axiomas mencionados anteriormente. Eso es, desentraÃ±ando las
definiciones, vemos que una definiciÃ³n sensata de $F â‰¤ G$ es ~G.sets âŠ† F.sets~,
porque queremos $G âŠ† S$ implica $F âŠ† S$.

Probablemente finalmente valga la pena mencionar que en Bourbaki, donde se
introdujo este concepto por primera vez, tienen un axioma adicional en sus
filtros: no permiten que $ğ“Ÿ âˆ…$ sea un filtro (el conjunto vacÃ­o no es un
conjunto generalizado). En esta Ã³ptica, esto parece una decisiÃ³n muy extraÃ±a, y
este axioma adicional se eliminÃ³ en Lean. De hecho, bendecimos a $ğ“Ÿ âˆ…$ con un
nombre especial: es $âŠ¥$, el Ãºnico filtro mÃ¡s pequeÃ±o bajo nuestro orden $â‰¤$. La
(pequeÃ±a) ventaja de la convenciÃ³n de Bourbaki es que un ultrafiltro puede
definirse literalmente como un elemento mÃ­nimo en el tipo de todos los filtros,
en lugar de un elemento mÃ­nimo en el tipo de todos los filtros excepto $âŠ¥$. Esto
serÃ­a anÃ¡logo a no permitir un anillo $R$ ser un ideal en sÃ­ mismo, por lo que
uno puede definir los ideales mÃ¡ximos de un anillo como los elementos mÃ¡ximos en
el conjunto de todos los ideales del anillo. Sin embargo, esta convenciÃ³n para
los ideales romperÃ­a enormemente la funcionalidad de los ideales, por ejemplo,
la imagen de un ideal a lo largo de un homomorfismo de anillo podrÃ­a dejar de
ser un ideal, la suma de dos ideales podrÃ­a no ser un ideal, y asÃ­
sucesivamente. De manera similar, permitimos que $âŠ¥$ sea un filtro en Lean,
porque nos permite tomar la intersecciÃ³n de filtros, tirar de los filtros hacia
atrÃ¡s y asÃ­ sucesivamente; da una definiciÃ³n mucho mÃ¡s funcional.

* Â¿QuÃ© hay en el taller de hoy?

El material de esta semana estÃ¡ en la [[https://github.com/ImperialCollegeLondon/formalising-mathematics/tree/master/src/week_5][semana_5]] del [[https://github.com/ImperialCollegeLondon/formalising-mathematics][repositorio de GitHub de
formalizaciÃ³n de las matemÃ¡ticas]] que puede descargar localmente si se tiene
~leanproject~ instalado o, si tiene la paciencia de un santo y no le importa
perderse algunas de las campanas y silbidos, puede probar en lÃ­nea ([[https://leanprover-community.github.io/lean-web-editor/#url=https%3A%2F%2Fraw.githubusercontent.com%2FImperialCollegeLondon%2Fformalising-mathematics%2Fmaster%2Fsrc%2Fweek_5%2FPart_A_filters.lean][Parte A]] y
[[https://leanprover-community.github.io/lean-web-editor/#url=https%3A%2F%2Fraw.githubusercontent.com%2FImperialCollegeLondon%2Fformalising-mathematics%2Fmaster%2Fsrc%2Fweek_5%2FPart_B_topology.lean][Parte B]]). Nota: toda esta infraestructura no apareciÃ³ simplemente por arte de
magia, escribÃ­ el cÃ³digo en el repositorio, pero no tuve nada que ver con todos
estos otros trucos para facilitar el uso de los matemÃ¡ticos; tenemos mucho que
agradecer a personas como Patrick Massot y Bryan Gin-ge Chen por ello.

En la Parte A comenzamos definiendo filtros principales y creamos una API bÃ¡sica
para ellos. Doy un par de ejemplos de filtros tambiÃ©n; por ejemplo, el filtro
cofinito $C$ sobre $X$, formado por todos los subconjuntos de $X$ cuyo
complemento es finito. Vale la pena detenerse en este filtro. Corresponde a un
al subconjunto genÃ©rico de $X$ de "todos los elementos de excepto quizÃ¡s un
nÃºmero finito", quizÃ¡s anÃ¡logo a un punto genÃ©rico en geometrÃ­a algebraica. Sin
embargo, no existe ningÃºn elemento $a$ de $X$ tal que $ğ“Ÿ {a} â‰¤ C$, porque $X -
{a}$ es un subconjunto de cofinitos que no contiene $a$. En particular, volviendo
a pensar en los filtros como subconjuntos generalizados, observamos que mientras
que un conjunto generalizado estÃ¡ determinado por los conjuntos que lo
contienen, definitivamente no estÃ¡ determinado por los conjuntos que contiene:
de hecho, $C$ no contiene conjuntos no vacÃ­os en absoluto.

En la Parte B pasamos a hacer algo de topologÃ­a. Definimos filtros de entornos y
puntos de acumulaciÃ³n, y luego hablamos de una definiciÃ³n de compacidad que no
involucra conjuntos abiertos en absoluto, sino que involucra filtros. TodavÃ­a
estoy tratando de internalizar esta definiciÃ³n, que es la siguiente:

#+begin_src lean
def is_compact (S : set X) := âˆ€ â¦ƒFâ¦„ [ne_bot F], F â‰¤ ğ“Ÿ S â†’ âˆƒ a  âˆˆ S, cluster_pt a F
#+end_src

En palabras, un subconjunto $S$ de un espacio topolÃ³gico es compacto si cada
subconjunto generalizado no vacÃ­o $F$ de $S$ tiene un punto de acumulaciÃ³n $a$
en $S$.

Pensemos en el siguiente ejemplo. Sea $S = X$. Sea $S$ un espacio topolÃ³gico
discreto infinito. Entonces, el filtro de cofinitos es un filtro de $S$ que no
tiene ningÃºn punto de acumulaciÃ³n, lo que significa que un espacio topolÃ³gico
discreto infinito no es compacto. Similarmente imagine que $S$ es el intervalo
semiabierto $(0,1)$. Entonces el filtro de entornos de cero en $â„$, restringido
a este subconjunto (es decir, simplemente interseca todos los conjuntos en el
filtro con $(0,1)$), nuevamente no tiene puntos de acumulaciÃ³n, por lo que este
espacio tampoco es compacto. Finalmente consideremos a $â„$. Entonces, el ~t_top~
filtro, en el que pensaremos en la Parte A, consta de todos los subconjuntos $T$
de $â„$ para los que existe alguno $r âˆˆ â„$ tal que $(r, âˆ) âŠ† T$. Este "entorno de
$+âˆ$" no tiene puntos de acumulaciÃ³n en $â„$ (tenga en cuenta que $+âˆ$ serÃ­a un
punto de acumulaciÃ³n, pero no es un nÃºmero real). Por tanto, $â„$ tampoco es
compacto. Ciertamente, no hemos probado aquÃ­ que esta definiciÃ³n de compacto sea
matemÃ¡ticamente equivalente a la habitual; pero lo es y si estÃ¡ interesado y ha
aprendido el lenguaje de Lean, puede ir y leer la prueba usted mismo en
biblioteca de matemÃ¡ticas de Lean.

El objetivo de esta semana es, nuevamente, demostrar que un subespacio cerrado
de un espacio compacto es compacto. Pero esta vez lo probamos con filtros. Como
la Ãºltima vez, probamos algo un poco mÃ¡s general: si $X$ es cualquier espacio
topolÃ³gico, $S$ es un subconjunto compacto y $C$ es un subconjunto cerrado,
entonces $S âˆ© C$ es compacto. Esta es la prueba. Sea $F$ un subconjunto
generalizado no vacÃ­o (es decir, un filtro) contenido en $S âˆ© C$. Por compacidad
de $S$, $F$ tiene un punto de acumulaciÃ³n $a$ en $S$. Pero $F$ estÃ¡ contenido en
$C$, por lo que todos los puntos de aacumulaciÃ³n de $F$ son puntos de
acumulaciÃ³n de $C$, y los puntos de acumulaciÃ³n de $C$ son solo el cierre de
$C$, que es de $C$. De ahÃ­, $a$ es el elemento de $S âˆ© C$ que buscamos. Sin
recubrimientos ni subrecubrimientos finitos.
